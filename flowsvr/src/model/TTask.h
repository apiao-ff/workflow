/*
 *
 *  TTask.h
 *  DO NOT EDIT. This file is generated by drogon_ctl
 *
 *
/



/*
================================================================================
Drogon ORM 与 GORM 动态表映射能力对比说明
================================================================================
1. 模型定义方式：
   - Drogon ORM：通过 drogon_ctl 工具，依据数据库中现有的表结构自动生成 C++ 模型类。
   - GORM：开发者手动定义 Go 的结构体，字段可通过 tag 与数据库字段映射。

2. 表名绑定方式：
   - Drogon ORM：模型类与表名在编译期间静态绑定，无法动态切换。
   - GORM：通过结构体名默认推导表名，也可运行时使用 .Table("table_name") 指定。

3. 分表/动态表支持：
   - Drogon ORM：不支持动态表名绑定，只能通过 SQL 拼接手动访问不同表。
   - GORM：同一个结构体可运行时映射到不同表，天然支持分表策略。

4. 底层机制区别：
   - Drogon ORM：基于 C++ 模板与静态类型系统，性能高但灵活性弱。
   - GORM：基于 Go 的反射系统，支持动态行为，适合业务灵活扩展。
*/



/*
 *
 * 关于 TTask 支持多张任务分表的三种方案说明：
 *
 * 1. 保持 static 成员 tableName + 手动 SQL 拼接（当前方案）
 *    - 表名通过函数 GetTableName(taskType, pos) 动态生成；
 *    - 所有 DAO 操作通过 execSql 拼接 SQL 字符串完成；
 *    - 简单灵活，适合任务类型和表名在运行时动态变化的场景；
 *    - 缺点是无法使用 drogon::orm::Mapper<TTask> 进行自动映射，代码维护复杂度略高。
 *
 * 2. 使用 thread_local static tableName_（线程局部静态变量）
 *    - 每个线程拥有独立的表名设置，允许在不同线程同时访问不同表；
 *    - 兼容 Mapper<TTask> 使用，但必须保证跨线程不共享同一个实例；
 *    - 适合任务调度模型中线程职责明确、线程不共享任务类型的情况；
 *    - 不适合线程池或异步跨线程调用，存在潜在并发风险。
 *
 * 3. 模板化 TTask 和 TaskDao（如 TTask<"task_type_1">）
 *    - 每张任务表使用一个独立模板类型绑定（compile-time 表名）；
 *    - 完美支持 Mapper<T>，类型安全、性能优；
 *    - 适合任务类型较少、表结构稳定、提前可知的场景；
 *    - 缺点是模板实例可能较多，泛型代码膨胀，增加编译与维护成本；
 *    - 无法应对运行时动态创建的任务类型表。
 *
*/






#pragma once
#include <drogon/orm/Result.h>
#include <drogon/orm/Row.h>
#include <drogon/orm/Field.h>
#include <drogon/orm/SqlBinder.h>
#include <drogon/orm/Mapper.h>
#include <drogon/orm/BaseBuilder.h>
#ifdef __cpp_impl_coroutine
#include <drogon/orm/CoroMapper.h>
#endif
#include <trantor/utils/Date.h>
#include <trantor/utils/Logger.h>
#include <json/json.h>
#include <string>
#include <memory>
#include <vector>
#include <tuple>
#include <stdint.h>
#include <iostream>

namespace drogon
{
namespace orm
{
class DbClient;
using DbClientPtr = std::shared_ptr<DbClient>;
}
}
namespace drogon_model
{
namespace workflow
{

class TTask
{
public:
    struct Cols
    {
        static const std::string _id;
        static const std::string _user_id;
        static const std::string _task_id;
        static const std::string _task_type;
        static const std::string _task_stage;
        static const std::string _status;
        static const std::string _priority;
        static const std::string _crt_retry_num;
        static const std::string _max_retry_num;
        static const std::string _max_retry_interval;
        static const std::string _schedule_log;
        static const std::string _task_context;
        static const std::string _order_time;
        static const std::string _create_time;
        static const std::string _modify_time;
    };

    const static int primaryKeyNumber;
    const static std::string tableName;
    // static std::string tableName;
    // void setTable(const std::string& table_Name) { tableName = table_Name; }

    const static bool hasPrimaryKey;
    const static std::string primaryKeyName;
    using PrimaryKeyType = int32_t;
    const PrimaryKeyType& getPrimaryKey() const;

    /**
     * @brief constructor
     * @param r One row of records in the SQL query result.
     * @param indexOffset Set the offset to -1 to access all columns by column names,
     * otherwise access all columns by offsets.
     * @note If the SQL is not a style of 'select * from table_name ...' (select all
     * columns by an asterisk), please set the offset to -1.
     */
    explicit TTask(const drogon::orm::Row& r, const ssize_t indexOffset = 0) noexcept;

    /**
     * @brief constructor
     * @param pJson The json object to construct a new instance.
     */
    explicit TTask(const Json::Value& pJson) noexcept(false);

    /**
     * @brief constructor
     * @param pJson The json object to construct a new instance.
     * @param pMasqueradingVector The aliases of table columns.
     */
    TTask(const Json::Value& pJson, const std::vector<std::string>& pMasqueradingVector) noexcept(false);

    TTask() = default;

    void updateByJson(const Json::Value& pJson) noexcept(false);
    void updateByMasqueradedJson(const Json::Value& pJson,
        const std::vector<std::string>& pMasqueradingVector) noexcept(false);
    static bool validateJsonForCreation(const Json::Value& pJson, std::string& err);
    static bool validateMasqueradedJsonForCreation(const Json::Value&,
        const std::vector<std::string>& pMasqueradingVector,
        std::string& err);
    static bool validateJsonForUpdate(const Json::Value& pJson, std::string& err);
    static bool validateMasqueradedJsonForUpdate(const Json::Value&,
        const std::vector<std::string>& pMasqueradingVector,
        std::string& err);
    static bool validJsonOfField(size_t index,
        const std::string& fieldName,
        const Json::Value& pJson,
        std::string& err,
        bool isForCreation);

/**  For column id  */
///Get the value of the column id, returns the default value if the column is null
    const int32_t& getValueOfId() const noexcept;
    ///Return a shared_ptr object pointing to the column const value, or an empty shared_ptr object if the column is null
    const std::shared_ptr<int32_t>& getId() const noexcept;
    ///Set the value of the column id
    void setId(const int32_t& pId) noexcept;

    /**  For column user_id  */
    ///Get the value of the column user_id, returns the default value if the column is null
    const std::string& getValueOfUserId() const noexcept;
    ///Return a shared_ptr object pointing to the column const value, or an empty shared_ptr object if the column is null
    const std::shared_ptr<std::string>& getUserId() const noexcept;
    ///Set the value of the column user_id
    void setUserId(const std::string& pUserId) noexcept;
    void setUserId(std::string&& pUserId) noexcept;

    /**  For column task_id  */
    ///Get the value of the column task_id, returns the default value if the column is null
    const std::string& getValueOfTaskId() const noexcept;
    ///Return a shared_ptr object pointing to the column const value, or an empty shared_ptr object if the column is null
    const std::shared_ptr<std::string>& getTaskId() const noexcept;
    ///Set the value of the column task_id
    void setTaskId(const std::string& pTaskId) noexcept;
    void setTaskId(std::string&& pTaskId) noexcept;

    /**  For column task_type  */
    ///Get the value of the column task_type, returns the default value if the column is null
    const std::string& getValueOfTaskType() const noexcept;
    ///Return a shared_ptr object pointing to the column const value, or an empty shared_ptr object if the column is null
    const std::shared_ptr<std::string>& getTaskType() const noexcept;
    ///Set the value of the column task_type
    void setTaskType(const std::string& pTaskType) noexcept;
    void setTaskType(std::string&& pTaskType) noexcept;

    /**  For column task_stage  */
    ///Get the value of the column task_stage, returns the default value if the column is null
    const std::string& getValueOfTaskStage() const noexcept;
    ///Return a shared_ptr object pointing to the column const value, or an empty shared_ptr object if the column is null
    const std::shared_ptr<std::string>& getTaskStage() const noexcept;
    ///Set the value of the column task_stage
    void setTaskStage(const std::string& pTaskStage) noexcept;
    void setTaskStage(std::string&& pTaskStage) noexcept;

    /**  For column status  */
    ///Get the value of the column status, returns the default value if the column is null
    const uint8_t& getValueOfStatus() const noexcept;
    ///Return a shared_ptr object pointing to the column const value, or an empty shared_ptr object if the column is null
    const std::shared_ptr<uint8_t>& getStatus() const noexcept;
    ///Set the value of the column status
    void setStatus(const uint8_t& pStatus) noexcept;

    /**  For column priority  */
    ///Get the value of the column priority, returns the default value if the column is null
    const int32_t& getValueOfPriority() const noexcept;
    ///Return a shared_ptr object pointing to the column const value, or an empty shared_ptr object if the column is null
    const std::shared_ptr<int32_t>& getPriority() const noexcept;
    ///Set the value of the column priority
    void setPriority(const int32_t& pPriority) noexcept;

    /**  For column crt_retry_num  */
    ///Get the value of the column crt_retry_num, returns the default value if the column is null
    const int32_t& getValueOfCrtRetryNum() const noexcept;
    ///Return a shared_ptr object pointing to the column const value, or an empty shared_ptr object if the column is null
    const std::shared_ptr<int32_t>& getCrtRetryNum() const noexcept;
    ///Set the value of the column crt_retry_num
    void setCrtRetryNum(const int32_t& pCrtRetryNum) noexcept;

    /**  For column max_retry_num  */
    ///Get the value of the column max_retry_num, returns the default value if the column is null
    const int32_t& getValueOfMaxRetryNum() const noexcept;
    ///Return a shared_ptr object pointing to the column const value, or an empty shared_ptr object if the column is null
    const std::shared_ptr<int32_t>& getMaxRetryNum() const noexcept;
    ///Set the value of the column max_retry_num
    void setMaxRetryNum(const int32_t& pMaxRetryNum) noexcept;

    /**  For column max_retry_interval  */
    ///Get the value of the column max_retry_interval, returns the default value if the column is null
    const int32_t& getValueOfMaxRetryInterval() const noexcept;
    ///Return a shared_ptr object pointing to the column const value, or an empty shared_ptr object if the column is null
    const std::shared_ptr<int32_t>& getMaxRetryInterval() const noexcept;
    ///Set the value of the column max_retry_interval
    void setMaxRetryInterval(const int32_t& pMaxRetryInterval) noexcept;

    /**  For column schedule_log  */
    ///Get the value of the column schedule_log, returns the default value if the column is null
    const std::string& getValueOfScheduleLog() const noexcept;
    ///Return a shared_ptr object pointing to the column const value, or an empty shared_ptr object if the column is null
    const std::shared_ptr<std::string>& getScheduleLog() const noexcept;
    ///Set the value of the column schedule_log
    void setScheduleLog(const std::string& pScheduleLog) noexcept;
    void setScheduleLog(std::string&& pScheduleLog) noexcept;

    /**  For column task_context  */
    ///Get the value of the column task_context, returns the default value if the column is null
    const std::string& getValueOfTaskContext() const noexcept;
    ///Return a shared_ptr object pointing to the column const value, or an empty shared_ptr object if the column is null
    const std::shared_ptr<std::string>& getTaskContext() const noexcept;
    ///Set the value of the column task_context
    void setTaskContext(const std::string& pTaskContext) noexcept;
    void setTaskContext(std::string&& pTaskContext) noexcept;

    /**  For column order_time  */
    ///Get the value of the column order_time, returns the default value if the column is null
    const int32_t& getValueOfOrderTime() const noexcept;
    ///Return a shared_ptr object pointing to the column const value, or an empty shared_ptr object if the column is null
    const std::shared_ptr<int32_t>& getOrderTime() const noexcept;
    ///Set the value of the column order_time
    void setOrderTime(const int32_t& pOrderTime) noexcept;

    /**  For column create_time  */
    ///Get the value of the column create_time, returns the default value if the column is null
    const ::trantor::Date& getValueOfCreateTime() const noexcept;
    ///Return a shared_ptr object pointing to the column const value, or an empty shared_ptr object if the column is null
    const std::shared_ptr<::trantor::Date>& getCreateTime() const noexcept;
    ///Set the value of the column create_time
    void setCreateTime(const ::trantor::Date& pCreateTime) noexcept;

    /**  For column modify_time  */
    ///Get the value of the column modify_time, returns the default value if the column is null
    const ::trantor::Date& getValueOfModifyTime() const noexcept;
    ///Return a shared_ptr object pointing to the column const value, or an empty shared_ptr object if the column is null
    const std::shared_ptr<::trantor::Date>& getModifyTime() const noexcept;
    ///Set the value of the column modify_time
    void setModifyTime(const ::trantor::Date& pModifyTime) noexcept;


    static size_t getColumnNumber() noexcept { return 15; }
    static const std::string& getColumnName(size_t index) noexcept(false);

    Json::Value toJson() const;
    Json::Value toMasqueradedJson(const std::vector<std::string>& pMasqueradingVector) const;
    /// Relationship interfaces
private:
    friend drogon::orm::Mapper<TTask>;
    friend drogon::orm::BaseBuilder<TTask, true, true>;
    friend drogon::orm::BaseBuilder<TTask, true, false>;
    friend drogon::orm::BaseBuilder<TTask, false, true>;
    friend drogon::orm::BaseBuilder<TTask, false, false>;
#ifdef __cpp_impl_coroutine
    friend drogon::orm::CoroMapper<TTask>;
#endif
    static const std::vector<std::string>& insertColumns() noexcept;
    void outputArgs(drogon::orm::internal::SqlBinder& binder) const;
    const std::vector<std::string> updateColumns() const;
    void updateArgs(drogon::orm::internal::SqlBinder& binder) const;
    ///For mysql or sqlite3
    void updateId(const uint64_t id);
    std::shared_ptr<int32_t> id_;
    std::shared_ptr<std::string> userId_;
    std::shared_ptr<std::string> taskId_;
    std::shared_ptr<std::string> taskType_;
    std::shared_ptr<std::string> taskStage_;
    std::shared_ptr<uint8_t> status_;
    std::shared_ptr<int32_t> priority_;
    std::shared_ptr<int32_t> crtRetryNum_;
    std::shared_ptr<int32_t> maxRetryNum_;
    std::shared_ptr<int32_t> maxRetryInterval_;
    std::shared_ptr<std::string> scheduleLog_;
    std::shared_ptr<std::string> taskContext_;
    std::shared_ptr<int32_t> orderTime_;
    std::shared_ptr<::trantor::Date> createTime_;
    std::shared_ptr<::trantor::Date> modifyTime_;
    struct MetaData
    {
        const std::string colName_;
        const std::string colType_;
        const std::string colDatabaseType_;
        const ssize_t colLength_;
        const bool isAutoVal_;
        const bool isPrimaryKey_;
        const bool notNull_;
    };
    static const std::vector<MetaData> metaData_;
    bool dirtyFlag_[15] = { false };
public:
    static const std::string& sqlForFindingByPrimaryKey()
    {
        static const std::string sql = "select * from " + tableName + " where id = ?";
        return sql;
    }

    static const std::string& sqlForDeletingByPrimaryKey()
    {
        static const std::string sql = "delete from " + tableName + " where id = ?";
        return sql;
    }
    std::string sqlForInserting(bool& needSelection) const
    {
        std::string sql = "insert into " + tableName + " (";
        size_t parametersCount = 0;
        needSelection = false;
        sql += "id,";
        ++parametersCount;
        if (dirtyFlag_[1])
        {
            sql += "user_id,";
            ++parametersCount;
        }
        if (dirtyFlag_[2])
        {
            sql += "task_id,";
            ++parametersCount;
        }
        if (dirtyFlag_[3])
        {
            sql += "task_type,";
            ++parametersCount;
        }
        if (dirtyFlag_[4])
        {
            sql += "task_stage,";
            ++parametersCount;
        }
        sql += "status,";
        ++parametersCount;
        if (!dirtyFlag_[5])
        {
            needSelection = true;
        }
        sql += "priority,";
        ++parametersCount;
        if (!dirtyFlag_[6])
        {
            needSelection = true;
        }
        sql += "crt_retry_num,";
        ++parametersCount;
        if (!dirtyFlag_[7])
        {
            needSelection = true;
        }
        sql += "max_retry_num,";
        ++parametersCount;
        if (!dirtyFlag_[8])
        {
            needSelection = true;
        }
        sql += "max_retry_interval,";
        ++parametersCount;
        if (!dirtyFlag_[9])
        {
            needSelection = true;
        }
        if (dirtyFlag_[10])
        {
            sql += "schedule_log,";
            ++parametersCount;
        }
        if (dirtyFlag_[11])
        {
            sql += "task_context,";
            ++parametersCount;
        }
        sql += "order_time,";
        ++parametersCount;
        if (!dirtyFlag_[12])
        {
            needSelection = true;
        }
        sql += "create_time,";
        ++parametersCount;
        if (!dirtyFlag_[13])
        {
            needSelection = true;
        }
        sql += "modify_time,";
        ++parametersCount;
        if (!dirtyFlag_[14])
        {
            needSelection = true;
        }
        needSelection = true;
        if (parametersCount > 0)
        {
            sql[sql.length() - 1] = ')';
            sql += " values (";
        }
        else
            sql += ") values (";

        sql += "default,";
        if (dirtyFlag_[1])
        {
            sql.append("?,");

        }
        if (dirtyFlag_[2])
        {
            sql.append("?,");

        }
        if (dirtyFlag_[3])
        {
            sql.append("?,");

        }
        if (dirtyFlag_[4])
        {
            sql.append("?,");

        }
        if (dirtyFlag_[5])
        {
            sql.append("?,");

        }
        else
        {
            sql += "default,";
        }
        if (dirtyFlag_[6])
        {
            sql.append("?,");

        }
        else
        {
            sql += "default,";
        }
        if (dirtyFlag_[7])
        {
            sql.append("?,");

        }
        else
        {
            sql += "default,";
        }
        if (dirtyFlag_[8])
        {
            sql.append("?,");

        }
        else
        {
            sql += "default,";
        }
        if (dirtyFlag_[9])
        {
            sql.append("?,");

        }
        else
        {
            sql += "default,";
        }
        if (dirtyFlag_[10])
        {
            sql.append("?,");

        }
        if (dirtyFlag_[11])
        {
            sql.append("?,");

        }
        if (dirtyFlag_[12])
        {
            sql.append("?,");

        }
        else
        {
            sql += "default,";
        }
        if (dirtyFlag_[13])
        {
            sql.append("?,");

        }
        else
        {
            sql += "default,";
        }
        if (dirtyFlag_[14])
        {
            sql.append("?,");

        }
        else
        {
            sql += "default,";
        }
        if (parametersCount > 0)
        {
            sql.resize(sql.length() - 1);
        }
        sql.append(1, ')');
        LOG_TRACE << sql;
        return sql;
    }
};
} // namespace workflow
} // namespace drogon_model
